#!/usr/bin/python3
import sys, time, datetime, threading, pyinotify
import subprocess as sp
import numpy as np
import matplotlib as mp
import matplotlib.cm as cm

logfile = '/home/perlinm/scripts/.dzen-bar.log'
def log(str):
  with open(logfile,'a') as l:
    l.write('%s\n'%str)


### process inputs


try:
  char_width = int(sys.argv[1])
  bar_height = int(sys.argv[2])
except:
  char_width = 7
  bar_height = 16

bar_height = int(round(bar_height/2))

### global variables

# data entry order of appearance, left to right
order = ['cpu','net','batt','light','vol','time']

# data entries to update every second
update_sec = ['time','net','batt','cpu','vol']
update_sec = ['cpu','net','batt']

# directories
src = '/home/perlinm/scripts/status-bar/status-scripts/'

# width of bars in units of character width
vol_width = 4
batt_width = 4
light_width = 4
cpu_width = 3

# keyboard shortcuts in xmonad
net_pad = 'alt+F3'
htop_pad = 'alt+F4'

# all text objects
vals = {
  'time' : '',
  'vol' : '',
  'light' : '',
  'batt' : '',
  'net' : '',
  'cpu' : ''
}

# length limits
lens = {
  'batt-text' : 7,
  'net' : 18
}

# keys to simulate
keysims = {
  'vol' : [[1,'ctrl+slash'],[3,'ctrl+shift+slash'],
           [4,'ctrl+Down'],[5,'ctrl+Up']],
  'light' : [[1,'alt+slash'],[3,'alt+shift+slash'],
             [4,'alt+Down'],[5,'alt+Up']],
  'net' : [[1,net_pad]],
  'cpu' : [[1,htop_pad]]
}

# functions to update text objects
funs = {}


### misc functions


# get output of shell command as string
def run(args):
  return sp.check_output([str(arg) for arg in args]).rstrip().decode('utf-8')

# fix string length
pad = '..'
def set_length(length,string):
  if length > len(string):
    return string+' '*(length-len(string))
  else:
    return string[:(length-len(pad))]+pad

# format text by lengths, colors, and keysims
def format(key,text,color=None):
  if type(text) is not list:
    text = [text]
    color = [color]

  for i in range(len(text)):
    if color[i]:
      text[i] = run([src+'set-color',color[i],text[i]])

  joined_text = ''.join(text)
  if key in keysims:
    for sim in keysims[key]:
      joined_text = run([src+'add-key',sim[0],sim[1],joined_text])

  vals[key] = ' '.join(text)

# print all text objects
def update_bar():
  output = ''
  for key in order:
    output += ' '+vals[key]
  print(output)
  sys.stdout.flush()

# color maps
color_maps = [m for m in cm.datad if not m.endswith('_r')]
def get_cmap(name):
  return cm.get_cmap(color_maps[color_maps.index(name)])
def hex_color(rgb_color):
  return mp.colors.rgb2hex(rgb_color)

# convert script output to status bar
def make_bar(script,width):
  level = float(run([src+script]))
  text = run([src+'draw-bar',bar_height,
                     char_width*width,level])


### functions


# time
def time_fun():
  format('time',run([src+'time']))
funs['time'] = time_fun

data = {'light':''}

# volume
cm_vol = get_cmap('cool')
def volume_fun():
  level = float(run([src+'volume']))
  rect = run([src+'draw-bar',bar_height,
                     char_width*vol_width,level])

  state = run([src+'volume','state'])
  if state == 'on' and level > 0:
    color = hex_color(cm_vol(level))
  else:
    color = run([src+'color-name','red'])

  format('vol',rect,color)

funs['vol'] = volume_fun

# backlight brightness
light_color = run([src+'color-name','yellow'])
def light_fun():
  level = float(run([src+'backlight']))
  rect = run([src+'draw-bar',bar_height,
                     char_width*light_width,level])
  format('light',rect,light_color)

funs['light'] = light_fun

# battery info
cm_batt = get_cmap('autumn')
def batt_fun():
  # bar indicating charge
  level = float(run([src+'battery']))
  rect = run([src+'draw-bar',bar_height,
                     char_width*batt_width,level])
  rect_color = hex_color(cm_batt(level))

  # text indicating time to [dis]charge 
  state = run([src+'battery','state'])
  time_left = run([src+'battery','time']) 
  if state == 'Charging':
    time_left += '+'
  elif state == 'Discharging':
    time_left += '-'
  
  time_left = set_length(lens['batt-text'],time_left)

  format('batt',[time_left,rect],[None,rect_color])

funs['batt'] = batt_fun

# network info
def net_fun():
  text = run([src+'network'])
  text = set_length(lens['net'],text)
  format('net',text)

funs['net'] = net_fun

# cpu info
cpus = int(run(['nproc']))

def get_idles():
  stat = []
  with open('/proc/stat','r') as f:
    for line in f:
      if not 'cpu' in line:
        break
      stat.append(line)
  idles = np.array([int(s.split()[4]) for s in stat[1:]])
  return idles

old_idles = get_idles()
old_cpu_time = time.time()

def cpu_fun():
  global old_idles, old_cpu_time
  idles = get_idles()
  cpu_time = time.time()
  dt = cpu_time - old_cpu_time
  usages = list(100 - (idles - old_idles)/dt)
  rect = [None]*cpus
  color = [None]*cpus
  for i in range(cpus):
    usage = usages[i]/100
    rect[i] = run([src+'draw-bar',bar_height,
                       char_width*cpu_width,usage])
    color[i] = hex_color([float(usage)]*3)

  format('cpu',rect,color)

funs['cpu'] = cpu_fun


### polls

for key in funs:
  funs[key]()


def second_poll():
  while True:
    now = time.time() 
    for key in update_sec:
      funs[key]()
    update_bar()
    elapsed = time.time() - now
    #if elapsed < 1:
    #  time.sleep(1 - elapsed)

class BrightnessHandler(pyinotify.ProcessEvent):
  def process_IN_OPEN(self,event):
    funs['light']()
    update_bar()

def light_poll():
  wm = pyinotify.WatchManager()
  wm.add_watch('/sys/class/backlight/intel_backlight/uevent',
               pyinotify.IN_OPEN)
  eh = BrightnessHandler()
  notifier = pyinotify.Notifier(wm, eh) 
  notifier.loop()

second_thread = threading.Thread(target=second_poll)
second_thread.start()

light_thread = threading.Thread(target=light_poll)
light_thread.start()
